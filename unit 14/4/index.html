<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Document</title>
</head>
<header>
    <h1>Rest/Spread Operator Exercise</h1>
    <a href="../3/index.html">&lt; Prev</a>
    <a href="../../index.html">Home</a>
    <a href="../index.html">Unit 14</a>
    <a href="../5/index.html">Next &gt;</a>
</header>

<hr>

<body>
<h3>Given this function:</h3>
<br>
function filterOutOdds() { <br>
    var nums = Array.prototype.slice.call(arguments); <br>
    return nums.filter(function(num) { <br>
      return num % 2 === 0 <br>
    }); <br>
  } <br>
    
  <h3>Refactor it to use the rest operator & an arrow function:</h3>
  <br>
  <div>const filterOutOdds = (...nums) =&gt; nums.filter((num) =&gt; num % 2 == 0);</div>
  <br>

  <h3>findMin</h3>
  <p>Write a function called findMin that accepts a variable number of arguments and returns the smallest argument. Make sure to do this useing the rest and spread operator</p>
  <br>
  const findMin = (...nums) =&gt; Math.min(...nums);
  <br>
  <h3>mergeObjects</h3>
  <p>Write a function called mergeObjects that accepts two objects and returns a new object which contains all the keys and values of hte first object and second object</p>
  <br>
  const mergeObject = (object, obj) =&gt; ({ ...object, ...obj });
  <br>
  <h3>doubleAndReturnArgs</h3>
  <p>Write a function called doubleAndReturnArgs which accepts an array and a variable number of arguments. The function should return a new array with the original array values and all of additional arguments doubled.</p>
  <br>
  const doubleAndReturnArgs = (arr, ...nums) =&gt; [ 
  ...arr, 
  ...nums.map((num) =&gt; num * 2), 
]; 
<br>
  <h3>Slice and Dice!</h3>
  <p>For this section, write the following functions using rest, spread and refactor these functions to be arrow functions! Make sure that you are always returning a new array or object and not modifying the existing inputs.</p>
  <ul>
    <li><h5>function removeRandom(items){}</h5></li>
    <br>
    const removeRandom = (items) =&gt; { <br>
        let idx = Math.floor(Math.random() * items.length); <br>
        return [...items.slice(0, idx), ...items.slice(idx + 1)]; <br>
      }; <br>
      <br>
    <li><h5>function extend(array1, array2){}</h5></li>
    <p>const extend = (array1, array2) =&gt; [...array1, ...array2];</p>

    <li><h5>function addKeyVal(obj, key){}</h5></li>
    <br>
    const addKeyVal = (obj, key, val) =&gt; { <br>
        let newobj = {}; <br>
        newobj[key] = val; <br>
        return { ...obj, ...newobj }; <br>
      }; <br>
      <br>

      <li><h5>removeKey(obj, key){}</h5></li>
      <br>
      const removeKey = (obj, key) =&gt; { <br>
        delete obj[key]; <br>
        return obj; <br>
      }; <br>
      <br>

    <li><h5>function combine(obj1, obj2){}</h5></li>
    <p>const combine = (obj1, obj2) =&gt; ({ ...obj1, ...obj2 });</p>

    <li><h5>function update(obj, key, val){}</h5></li>
    <br>
    const update = (obj, key, val) =&gt; { <br>
        obj[key] = val; <br>
        return { ...obj }; <br>
      }; <br>
      <br>
  </ul>


    <script src="app.js"></script>
</body>
</html>